<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Low-latency Error Augmentation Framework for C++11">
<title>LEAF</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>LEAF</h1>
<div class="details">
<span id="author" class="author">Low-latency Error Augmentation Framework for C++11</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#_two_minute_introduction">Two Minute Introduction</a></li>
<li><a href="#_what_if_i_want_to_use_exception_handling">What If I Want to Use Exception Handling?</a></li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#tutorial-noexcept">Using LEAF without Exception Handling</a></li>
<li><a href="#tutorial-eh">Using LEAF with Exception Handling</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#e-types">e-types</a></li>
<li><a href="#expect">Class Template <code>expect</code></a>
<ul class="sectlevel3">
<li><a href="#expect::expect">Constructor</a></li>
<li><a href="#expect-dtor">Destructor</a></li>
<li><a href="#expect::propagate"><code>propagate</code></a></li>
<li><a href="#capture-expect"><code>capture</code></a></li>
<li><a href="#match"><code>match</code></a></li>
<li><a href="#handle_error-expect"><code>handle_error</code></a></li>
<li><a href="#peek-expect"><code>peek</code></a></li>
<li><a href="#diagnostic_output-expect"><code>diagnostic_output</code></a></li>
</ul>
</li>
<li><a href="#error">Class <code>error</code></a>
<ul class="sectlevel3">
<li><a href="#error::error">Constructor</a></li>
<li><a href="#error::propagate"><code>propagate</code></a></li>
<li><a href="#operator_eq-error"><code>operator==</code></a></li>
<li><a href="#operator_neq-error"><code>operator!=</code></a></li>
<li><a href="#operator_shl-error"><code>operator&lt;&lt;</code></a></li>
<li><a href="#error::peek_next_error"><code>peek_next_error</code></a></li>
</ul>
</li>
<li><a href="#preload"><code>preload</code></a></li>
<li><a href="#defer"><code>defer</code></a></li>
<li><a href="#error_capture">Class <code>error_capture</code></a>
<ul class="sectlevel3">
<li><a href="#error_capture::error_captere">Constructor</a></li>
<li><a href="#error_capture::operator_bool">Conversion to <code>bool</code></a></li>
<li><a href="#error_capture::unload"><code>unload</code></a></li>
<li><a href="#handle_error-error_capture"><code>handle_error</code></a></li>
<li><a href="#peek-error_capture"><code>peek</code></a></li>
<li><a href="#diagnostic_output-error_capture"><code>diagnostic_output</code></a></li>
</ul>
</li>
<li><a href="#result">Class template <code>result</code></a>
<ul class="sectlevel3">
<li><a href="#result::result">Constructors</a></li>
<li><a href="#result::operator_bool">Conversion to <code>bool</code></a></li>
<li><a href="#result::value"><code>value</code>/<code>operator*</code></a></li>
<li><a href="#result::error"><code>error</code></a></li>
<li><a href="#capture-result"><code>capture</code></a></li>
<li><a href="#handle_error-result"><code>handle_error</code></a></li>
<li><a href="#peek-result"><code>peek</code></a></li>
<li><a href="#diagnostic_output-result"><code>diagnostic_output</code></a></li>
<li><a href="#bad_result"><code>bad_result</code></a></li>
<li><a href="#LEAF_AUTO"><code>LEAF_AUTO</code></a></li>
<li><a href="#LEAF_CHECK"><code>LEAF_CHECK</code></a></li>
</ul>
</li>
<li><a href="#eh">Exception Handling Functions</a>
<ul class="sectlevel3">
<li><a href="#throw_exception"><code>throw_exception</code></a></li>
<li><a href="#capture_exception"><code>capture_exception</code></a></li>
<li><a href="#get"><code>get</code></a></li>
<li><a href="#get_error"><code>get_error</code></a></li>
<li><a href="#handle_exception"><code>handle_exception</code></a></li>
<li><a href="#peek-exception"><code>peek</code></a></li>
<li><a href="#diagnostic_output-exception"><code>diagnostic_output</code></a></li>
</ul>
</li>
<li><a href="#common">Common e-types</a></li>
</ul>
</li>
<li><a href="#techniques">Programming Techniques</a>
<ul class="sectlevel2">
<li><a href="#technique_preload">Preloading Errors</a></li>
<li><a href="#technique_defer">Capturing <code>errno</code> with <code>defer</code></a></li>
<li><a href="#technique_augment_in_catch">Augmenting Exceptions in a <code>catch</code></a></li>
<li><a href="#technique_preload_in_c_callbacks">Using <code>peek_next_error</code> in C-callbacks</a></li>
<li><a href="#technique_transport">Transporting Errors between Threads</a>
<ul class="sectlevel3">
<li><a href="#technique_transport-result">Using <code>result&lt;T&gt;</code></a></li>
<li><a href="#technique_transport-exceptions">Using Exception Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_design_rationale">Design Rationale</a></li>
<li><a href="#distribution">Distribution</a></li>
<li><a href="#building">Building</a></li>
<li><a href="#portability">Portability</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF is a non-intrusive C&#43;&#43;11 error handling library capable of transporting arbitrary error information from contexts that detect and report failures, as well as from intermediate error-neutral contexts, to scopes where the error is ultimately handled.</p>
</div>
<div class="paragraph">
<p>LEAF does not allocate dynamic memory<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>, which makes it suitable for low-latency and other performance-critical environments. It is equally applicable to programs that use exception handling and programs that do not.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
LEAF is compatible with, not a replacement for <code>std::error_code</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_two_minute_introduction">Two Minute Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Error handling with LEAF looks like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">{
  leaf::expect&lt;e_error_code, e_file_name, e_request_id&gt; exp; <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">if</span>( result&lt;T&gt; r = f() )
  {
    <span class="comment">//Success! </span><i class="conum" data-value="2"></i><b>(2)</b>
  }
  <span class="keyword">else</span>
  {
    <span class="comment">//Handle errors</span>

    <span class="predefined-type">bool</span> matched = leaf::handle_error( exp, r, <i class="conum" data-value="3"></i><b>(3)</b>

      leaf::match&lt;e_error_code, e_file_name, e_request_id&gt;( [ ]( <span class="predefined-type">int</span> ec, std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, uuid <span class="directive">const</span> &amp; id )
      {
        <i class="conum" data-value="4"></i><b>(4)</b>
      } ),

      leaf::match&lt;e_error_code, e_file_name&gt;( [ ]( <span class="predefined-type">int</span> ec, std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn )
      {
        <i class="conum" data-value="5"></i><b>(5)</b>
      } )
    );

  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case <code>f()</code> (next line) fails, error objects will be stored in <code>exp</code>, but only if their types are specified in the instantiation of the <code>expect</code> template (otherwise they&#8217;re discarded).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Successful result values are stored inside <code>r</code> of type <code>result&lt;T&gt;</code>, which is a value-or-error variant type.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>f()</code> has failed, so we pass <code>exp</code> and the returned <code>r</code> to <code>handle_error</code>, followed by several (in this case, two) sets of error object types to be matched (<code>handle_error</code> returns false if it doesn`t find a match).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Handle the case where we got <code>e_error_code</code>, <code>e_file_name</code> and <code>e_request_id</code> associated with the failure reported in <code>r</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Handle the case where we only got <code>e_error_code</code> and <code>e_file_name</code> associated with the failure reported in <code>r</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>e_error_code</code>, <code>e_file_name</code>, <code>e_request_id</code>, etc. are user-defined, e.g.:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_error_code { <span class="predefined-type">int</span> value; };

<span class="keyword">struct</span> e_file_name { std::<span class="predefined-type">string</span> value; };

<span class="keyword">struct</span> e_request_id { uuid value; };</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Reporting an error with LEAF looks like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;T&gt; g()
{
  <span class="keyword">if</span>( success )
    <span class="keyword">return</span> T(....);
  <span class="keyword">else</span>
    <span class="keyword">return</span> leaf::error( e_error_code{<span class="integer">42</span>}, e_request_id{id} ); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Report an error, store the passed <code>e_error_code</code> and <code>e_request_id</code> in <code>expect</code> object(s) from calling scopes.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Forwarding an error reported by a lower level function looks like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;T&gt; f()
{
  <span class="keyword">if</span>( leaf::error&lt;T&gt; r=g() )
  {
    ....
    <span class="keyword">return</span> r; <i class="conum" data-value="1"></i><b>(1)</b>
  }
  <span class="keyword">else</span>
    <span class="keyword">return</span> r.error( e_file_name{<span class="string"><span class="delimiter">&quot;</span><span class="content">file.txt</span><span class="delimiter">&quot;</span></span>} ); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Success, return <code>r</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Forward the error reported in <code>r</code>, in addition storing <code>e_file_name</code> in <code>expect</code> object(s) from calling scopes.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_if_i_want_to_use_exception_handling">What If I Want to Use Exception Handling?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>That would be a 1-minute introduction. :-)</p>
</div>
<div class="paragraph">
<p>Exception handling with LEAF looks like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">{
  leaf::expect&lt;e_error_code, e_file_name, e_request_id&gt; exp; <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">try</span>
  {
    f();
  }
  <span class="keyword">catch</span>( my_exception <span class="directive">const</span> &amp; e )
  {
    leaf::handle_exception( exp, e, <i class="conum" data-value="2"></i><b>(2)</b>

      leaf::match&lt;e_error_code, e_file_name, e_request_id&gt;( [ ]( <span class="predefined-type">int</span> ec, std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, uuid <span class="directive">const</span> &amp; id )
      {
        <i class="conum" data-value="3"></i><b>(3)</b>
      } ),

      leaf::match&lt;e_error_code, e_file_name&gt;( [ ]( <span class="predefined-type">int</span> ec, std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn )
      {
        <i class="conum" data-value="4"></i><b>(4)</b>
      } )
    );

  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case <code>f()</code> throws, error objects associated with the exception are stored in <code>exp</code>, but only if their types are specified in the instantiation of the <code>expect</code> template (otherwise they&#8217;re discarded).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We pass <code>exp</code> and the caught exception <code>e</code> to <code>handle_exception</code>, followed by several (in this case, two) sets of error object types to be matched (<code>handle_exception</code> rethrows the original exception if it doesn&#8217;t find a match).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle the case where we got <code>e_error_code</code>, <code>e_file_name</code> and <code>e_request_id</code>, associated with <code>e</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Handle the case where we only got <code>e_error_code</code> and <code>e_file_name</code>, associated with <code>e</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Error objects can be passed to LEAF at the point of the <code>throw</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> g()
{
  ....
  <span class="keyword">if</span>( failure )
    leaf::throw_exception( my_exception(), e_error_code{<span class="integer">42</span>}, e_request_id{id} ); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Throws <code>my_exception</code>, stores the passed <code>e_error_code</code> and <code>e_request_id</code> in <code>expect</code> object(s) from calling scopes.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Exceptions can be augmented in exception-neutral contexts:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> f()
{
  <span class="directive">auto</span> propagate = leaf::preload( e_file_name{<span class="string"><span class="delimiter">&quot;</span><span class="content">file.txt</span><span class="delimiter">&quot;</span></span>} ); <i class="conum" data-value="1"></i><b>(1)</b>

  g();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case <code>g()</code> throws (next line), additionally store this <code>e_file_name</code> object in <code>expect</code> object(s) from calling scopes, and associate it with the passing exception.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ll write a program that reads a text file in a buffer and prints it to <code>std::cout</code>, using LEAF to handle errors. We&#8217;ll implement two versions, one that uses exception handling, and one that does not. To see the source code of the complete programs from this tutorial follow these links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp?ts=3">print_file_result.cpp</a> (without exception handling)</p>
</li>
<li>
<p><a href="https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp?ts=3">print_file_eh.cpp</a> (with exception handling)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>First, let&#8217;s see how to use LEAF without exception handling.</p>
</div>
<div class="sect2">
<h3 id="tutorial-noexcept">Using LEAF without Exception Handling</h3>
<div class="paragraph">
<p>We&#8217;ll write a program that reads a text file in a buffer and prints it to <code>std::cout</code>, using LEAF to handle errors. First, we need an <code>enum</code> to define our different error codes, and a simple type <code>e_error_code</code> to help LEAF tell error codes apart from other <code>int</code> values:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">enum</span>
{
  input_file_open_error,
  input_file_size_error,
  input_file_read_error,
  input_eof_error,
  cout_error
};

<span class="keyword">struct</span> e_error_code { <span class="predefined-type">int</span> value; };</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We don&#8217;t need an enumerated value that indicates success. That&#8217;s because we will use the convenient class template <code><a href="#result">result</a>&lt;T&gt;</code> as the return type in functions which may fail. It is a value-or-error variant type which holds a <code>T</code> except if initialized with a <code>leaf::<a href="#error">error</a></code>.</p>
</div>
<div class="paragraph">
<p>Here is a function that reads data from a file into a buffer and reports the various errors which may occur (it returns <code>result&lt;void&gt;</code> because in case of success it doesn&#8217;t return a value):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="directive">void</span>&gt; file_read( FILE &amp; f, <span class="directive">void</span> * buf, <span class="predefined-type">int</span> size )
{
  <span class="predefined-type">int</span> n = fread(buf,<span class="integer">1</span>,size,&amp;f);
  <span class="keyword">if</span>( ferror(&amp;f) )
    <span class="keyword">return</span> leaf::error( e_error_code{input_file_read_error}, e_errno{errno} ); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">if</span>( n!=size )
    <span class="keyword">return</span> leaf::error( e_error_code{input_eof_error} ); <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="keyword">return</span> { }; <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If <code>ferror</code> indicates an error, we return <code>input_file_read_error</code> and, because there is a relevant <code>errno</code> code, we <em>also</em> pass that to the <code>leaf::<a href="#error">error</a></code> constructor (LEAF defines <code>struct e_errno { int value; }</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If <code>fread</code> reports that it couldn&#8217;t read all of the data requested, we return <code>input_eof_error</code>. In this case there is no relevant <code>errno</code> to pass on, because this is not an error as far as <code>fread</code> is concerned.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>result&lt;void&gt;</code> can be initialized with <code>{ }</code> to indicate success.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>e_error_code</code> and <code>e_errno</code> structs are examples of types that may be passed to the <code>leaf::error</code> constructor. The requirement for such types is that they define an accessible data member <code>value</code> and <code>noexcept</code> move constructor. These types allow us to assign different error-related semantics to different valies of otherwise identical static types.<br>
<br>
For example, we could define <code>struct e_input_name { std::string value; }</code> and <code>struct e_output_name { std::string value; }</code> and LEAF will treat them as separate entities even though their <code>.value</code> members are of the same type <code>std::string</code>.<br>
<br>
In this text we refer to such types as <a href="#e-types">e-types</a>, because by convention they use the <code>e_</code> prefix.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, let&#8217;s consider a possible caller of <code>file_read</code>, called <code>print_file</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="directive">void</span>&gt; print_file( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name )
{
  leaf::result&lt;std::shared_ptr&lt;FILE&gt;&gt; f = file_open(file_name);
  <span class="keyword">if</span>( !f ) <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> f.error(); <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="directive">auto</span> propagate = leaf::preload( e_file_name{file_name} ); <i class="conum" data-value="3"></i><b>(3)</b>

  leaf::result&lt;<span class="predefined-type">int</span>&gt; s = file_size(*f.value());
  <span class="keyword">if</span>( !s ) <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="keyword">return</span> s.error(); <i class="conum" data-value="5"></i><b>(5)</b>

  std::<span class="predefined-type">string</span> buffer( <span class="integer">1</span>+s.value(), <span class="char">'\0'</span> );
  leaf::result&lt;<span class="directive">void</span>&gt; fr = file_read(*f.value,&amp;buffer[<span class="integer">0</span>],buffer.size()-<span class="integer">1</span>);
  <span class="keyword">if</span>( !fr )
    <span class="keyword">return</span> fr.error();

  std::cout &lt;&lt; buffer;
  std::cout.flush();
  <span class="keyword">if</span>( std::cout.fail() )
    <span class="keyword">return</span> leaf::error( e_error_code{cout_error} ); <i class="conum" data-value="6"></i><b>(6)</b>

  <span class="keyword">return</span> { }; <i class="conum" data-value="7"></i><b>(7)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If <code>file_open</code> returns an error&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;we forward it to the caller. Notice that we don&#8217;t return <code>leaf::error()</code>, which would indicate a newly detected error; we return <code>f.error()</code>, which propagates the error already stored in <code>f</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code><a href="#preload">preload</a></code> takes any number of <a href="#e-types">e-types</a> and prepares them to become associated (automatically, at the time the returned object expires) with the first <code>leaf::<a href="#error">error</a></code> value created thereafter. The effect is that from this point on, any error returned or forwarded by <code>print_file</code> will have an associated file name, in addition to everything else passed to <code>leaf::<a href="#error">error</a></code> explicitly (<code>e_file_name</code> is defined as <code>struct e_file_name { std::string value; }</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>If <code>file_size</code> returns an error&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;we forward it to the caller.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>If <code>std::cout</code> fails to write the buffer, we return <code>cout_error</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Success!</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice the repetitiveness in simply forwarding errors to the caller. LEAF defines two macros, <code><a href="#LEAF_AUTO">LEAF_AUTO</a></code> and <code><a href="#LEAF_CHECK">LEAF_CHECK</a></code>, which can help reduce the clutter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>LEAF_AUTO</code> macro takes two arguments, an identifier and a <code>result&lt;T&gt;</code>. In case the passed <code>result&lt;T&gt;</code> indicates an error, <code>LEAF_AUTO</code> returns that error to the caller (therefore control leaves the enclosing function). In case of success, <code>LEAF_AUTO</code> defines a variable, of type <code>T &amp;</code> (using the provided identifier) that refers to the <code>T</code> object stored inside the passed <code>result&lt;T&gt;</code>.</p>
</li>
<li>
<p>The <code>LEAF_CHECK</code> macro is designed to be used similarly in functions that return <code>result&lt;void&gt;</code>, but of course it doesn&#8217;t define a variable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below is the same <code>print_file</code> function simplified using <code>LEAF_AUTO</code> and <code>LEAF_CHECK</code> (remember that the variables defined by <code>LEAF_AUTO</code> are not of type <code>result&lt;T&gt;</code>, but of type <code>T &amp;</code>; for example <code>s</code> used to be <code>result&lt;int&gt;</code>, but now it is simply <code>int &amp;</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="directive">void</span>&gt; print_file( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name )
{
  LEAF_AUTO(f,file_open(file_name)); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="directive">auto</span> propagate = leaf::preload( e_file_name{file_name} );

  LEAF_AUTO(s,file_size(*f)); <i class="conum" data-value="2"></i><b>(2)</b>

  std::<span class="predefined-type">string</span> buffer( <span class="integer">1</span>+s, <span class="char">'\0'</span> );
  LEAF_CHECK(file_read(*f,&amp;buffer[<span class="integer">0</span>],buffer.size()-<span class="integer">1</span>)); <i class="conum" data-value="3"></i><b>(3)</b>

  std::cout &lt;&lt; buffer;
  std::cout.flush();
  <span class="keyword">if</span>( std::cout.fail() )
    <span class="keyword">return</span> leaf::error( e_error_code{cout_error} );

  <span class="keyword">return</span> { };
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Call <code>file_open</code>, check for errors, unpack the returned <code>result&lt;std::shared_ptr&lt;FILE&gt;&gt;</code> and define a variable <code>f</code> of type <code>std::shared_ptr&lt;FILE&gt; &amp;</code> that refers to its <code><a href="#result::value">value</a>()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Call <code>file_size</code>, check for errors, unpack the returned <code>result&lt;int&gt;</code> and define a variable <code>s</code> of type <code>int &amp;</code> that refers to its <code>value()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call <code>file_read</code>, check for errors (<code>file_read</code> returns <code>result&lt;void&gt;</code>).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s look at the <code>main</code> function, which handles all errors in this program:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] )
{
  <span class="predefined-type">char</span> <span class="directive">const</span> * fn = parse_command_line(argc,argv);
  <span class="keyword">if</span>( !fn )
  {
    std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad command line argument</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
    <span class="keyword">return</span> <span class="integer">1</span>;
  }

  leaf::expect&lt;e_error_code, e_file_name, e_errno&gt; exp; <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">if</span>( <span class="directive">auto</span> r = print_file(fn) )
  {
    <span class="keyword">return</span> <span class="integer">0</span>; <i class="conum" data-value="2"></i><b>(2)</b>
  }
  <span class="keyword">else</span>
  {
    <span class="keyword">switch</span>( <span class="directive">auto</span> ec = *leaf::peek&lt;e_error_code&gt;(exp,r) ) <i class="conum" data-value="3"></i><b>(3)</b>
    {
      <span class="keyword">case</span> input_file_open_error:
      {
        <span class="predefined-type">bool</span> matched = handle_error( exp, r, <i class="conum" data-value="4"></i><b>(4)</b>

          leaf::match&lt;e_file_name,e_errno&gt;( [ ] ( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
          {
            <span class="keyword">if</span>( errn==ENOENT )
              std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File not found: </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; std::endl;
            <span class="keyword">else</span>
              std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to open </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
          } )

        );
        assert(matched);
        <span class="keyword">return</span> <span class="integer">2</span>;
      }

      <span class="keyword">case</span> input_file_size_error:
      <span class="keyword">case</span> input_file_read_error:
      <span class="keyword">case</span> input_eof_error:
      {
        <span class="predefined-type">bool</span> matched = handle_error( exp, r, <i class="conum" data-value="5"></i><b>(5)</b>

          leaf::match&lt;e_file_name,e_errno&gt;( [ ] ( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
          {
            std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to access </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
          } ),

          leaf::match&lt;e_errno&gt;( [ ] ( <span class="predefined-type">int</span> errn )
          {
            std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I/O error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
          } ),

          leaf::match&lt;&gt;( [ ]
          {
            std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I/O error</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
          } )

        );
        assert(matched);
        <span class="keyword">return</span> <span class="integer">3</span>;
      }

      <span class="keyword">case</span> cout_error:
      {
        <span class="predefined-type">bool</span> matched = handle_error( exp, r, <i class="conum" data-value="6"></i><b>(6)</b>

          leaf::match&lt;e_errno&gt;( [ ] ( <span class="predefined-type">int</span> errn )
          {
            std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Output error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
          } )

        );
        assert(matched);
        <span class="keyword">return</span> <span class="integer">4</span>;
      }

      <span class="keyword">default</span>:
        std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown error code </span><span class="delimiter">&quot;</span></span> &lt;&lt; <span class="predefined-type">int</span>(ec) &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, cryptic information follows.</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl; <i class="conum" data-value="7"></i><b>(7)</b>
        diagnostic_output(std::cerr,exp,r);
        <span class="keyword">return</span> <span class="integer">5</span>;
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We expect <code>e_error_code</code>, <code>e_file_name</code> and <code>e_errno</code> objects to be associated with errors handled in this function. They will be stored inside <code>exp</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Success, we&#8217;re done!</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Probe <code>exp</code> for objects associated with the error stored in <code>r</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code><a href="#handle_error-expect">handle_error</a></code> takes a list of match objects (in this case only one), each given a set of <a href="#e-types">e-types</a>. It attempts to match each set (in order) to objects of e-types available in <code>exp</code>, which are associated with the <code><a href="#error">error</a></code> value stored in <code>r</code>. If no set can be matched, <code>handle_error</code> returns false. When a match is found, <code>handle_error</code> calls the corresponding lambda function, passing the <code>.value</code> of each of the e-types from the matched set.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>In this case <code>handle_error</code> is given 3 match sets. It will first check if both <code>e_file_name</code> and <code>e_errno</code>, associated with <code>r</code>, are avialable in <code>exp</code>; if not, it will next check if just <code>e_errno</code> is available; and if not, the last (empty) set will always match to print a generic error message.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Report failure to write to <code>std::cout</code>, print the relevant <code>errno</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This catch-all case helps diagnose logic errors (presumably, missing case labels in the <code>switch</code> statement).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To summarize, when using LEAF without exception handling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Functions that may fail return instances of <code><a href="#result">result</a>&lt;T&gt;</code>, a value-or-error variant class template.</p>
</li>
<li>
<p>In case a function detects a failure, the returned <code>result&lt;T&gt;</code> can be initialized implicitly by returning <code>leaf::<a href="#error">error</a></code>, which may be passed any and all information we have that is relevant to the failure, in the form of <a href="#e-types">e-types</a>.</p>
</li>
<li>
<p>When a lower level function reports an error, that error is forwarded to the caller, passing any additional relevant information available in the current scope.</p>
</li>
<li>
<p>In order for any <a href="#e-types">e-type</a> object passed to <code>leaf::<a href="#error">error</a></code> to be stored rather than discarded, the function that handles the error must contain an instance of the class template <code><a href="#expect">expect</a></code> that provides the necessary storage for that type.</p>
</li>
<li>
<p>Using <code><a href="#handle_error-expect">handle_error</a></code>, available <a href="#e-types">e-type</a> objects associated with the <code><a href="#error">error</a></code> value being handled can be matched to what is required in order to deal with that <code>error</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The complete program from this tutorial is available <a href="https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp?ts=3">here</a>. There is also <a href="https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp?ts=3">another</a> version of the same program that uses exception handling to report errors (see <a href="#tutorial-eh">tutorial below</a>).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-eh">Using LEAF with Exception Handling</h3>
<div class="paragraph">
<p>And now, we&#8217;ll write the same program that reads a text file in a buffer and prints it to <code>std::cout</code>, this time using exceptions to report errors. First, we need to define our exception class hierarchy:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> print_file_error : <span class="directive">virtual</span> std::exception { };
<span class="keyword">struct</span> command_line_error : <span class="directive">virtual</span> print_file_error { };
<span class="keyword">struct</span> bad_command_line : <span class="directive">virtual</span> command_line_error { };
<span class="keyword">struct</span> input_error : <span class="directive">virtual</span> print_file_error { };
<span class="keyword">struct</span> input_file_error : <span class="directive">virtual</span> input_error { };
<span class="keyword">struct</span> input_file_open_error : <span class="directive">virtual</span> input_file_error { };
<span class="keyword">struct</span> input_file_size_error : <span class="directive">virtual</span> input_file_error { };
<span class="keyword">struct</span> input_file_read_error : <span class="directive">virtual</span> input_file_error { };
<span class="keyword">struct</span> input_eof_error : <span class="directive">virtual</span> input_file_error { };</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Here is a function that reads data from a file into a buffer and throws exceptions to communicate failures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> file_read( FILE &amp; f, <span class="directive">void</span> * buf, <span class="predefined-type">int</span> size )
{
  <span class="predefined-type">int</span> n = fread(buf,<span class="integer">1</span>,size,&amp;f);

  <span class="keyword">if</span>( ferror(&amp;f) )
    leaf::throw_exception( input_file_read_error(), e_errno{errno} ); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">if</span>( n!=size )
    <span class="keyword">throw</span> input_eof_error(); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If <code>ferror</code> indicates an error, we throw <code>input_file_read_error</code> and, because there is a relevant <code>errno</code> code, we pass that to <code><a href="#throw_exception">throw_exception</a></code> <em>also</em> (LEAF defines <code>struct e_errno { int value; }</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If <code>fread</code> reports that it couldn&#8217;t read all of the data requested, we throw <code>input_eof_error</code>. In this case there is no relevant <code>errno</code> to pass on, because this is not an error as far as <code>fread</code> is concerned.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>e_error_code</code> and <code>e_errno</code> structs are examples of types that may be passed to <code><a href="#throw_exception">throw_exception</a></code> (and to the <code>leaf::error</code> constructor). The requirement for such types is that they define an accessible data member <code>value</code> and <code>noexcept</code> move constructor. These types allow us to assign different error-related semantics to different valies of otherwise identical static types.<br>
<br>
For example, we could define <code>struct e_input_name { std::string value; }</code> and <code>struct e_output_name { std::string value; }</code> and LEAF will treat them as separate entities even though their <code>.value</code> members are of the same type <code>std::string</code>.<br>
<br>
In this text we refer to such types as <a href="#e-types">e-types</a>, because by convention they use the <code>e_</code> prefix.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, let&#8217;s consider a possible caller of <code>file_read</code>, called <code>print_file</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> print_file( <span class="predefined-type">char</span> <span class="directive">const</span> * file_name )
{
  std::shared_ptr&lt;FILE&gt; f = file_open( file_name ); <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="directive">auto</span> propagate1 = leaf::preload( e_file_name{file_name} ); <i class="conum" data-value="2"></i><b>(2)</b>

  std::<span class="predefined-type">string</span> buffer( <span class="integer">1</span>+file_size(*f), <span class="char">'\0'</span> ); <i class="conum" data-value="3"></i><b>(3)</b>
  file_read(*f,&amp;buffer[<span class="integer">0</span>],buffer.size()-<span class="integer">1</span>);

  <span class="directive">auto</span> propagate2 = leaf::defer( [ ] { <span class="keyword">return</span> e_errno{errno}; } ); <i class="conum" data-value="4"></i><b>(4)</b>
  std::cout &lt;&lt; buffer;
  std::cout.flush();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>std::shared_ptr&lt;FILE&gt; file_open( char const * file_name)</code> throws on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code><a href="#preload">preload</a></code> takes any number of <a href="#e-types">e-type</a> objects and prepares them to become associated (automatically, at the time the returned object expires) with the first exception thrown thereafter. The effect is that from this point on, any exception escaping <code>print_file</code> will report the file name, in addition to everything else passed to <code><a href="#throw_exception">throw_exception</a></code> explicitly (<code>e_file_name</code> is defined as <code>struct e_file_name { std::string value; }</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>int file_size( FILE &amp; f )</code> throws on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code><a href="#defer">defer</a></code> is similar to <code>preload</code>: it prepares an e-type object to become associated with the first exception thrown thereafter, but instead of taking the e-type object itself, <code>defer</code> takes a function that returns it. The function is invoked in the returned object`s destructor, at which point it becomes associated with the exception being propagated. Assuming <code>std::cout</code> is configured to throw on error, the effect of this line is that those exceptions will have the relevant <code>errno</code> associated with them.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s consider the <code>main</code> function, which is able to handle exceptions thrown by <code>print_file</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] )
{
   std::cout.exceptions ( std::ostream::failbit | std::ostream::badbit ); <i class="conum" data-value="1"></i><b>(1)</b>

  leaf::expect&lt;e_file_name, e_errno&gt; exp; <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="keyword">try</span>
  {
    print_file(parse_command_line(argc,argv));
    <span class="keyword">return</span> <span class="integer">0</span>;
  }
  <span class="keyword">catch</span>( bad_command_line <span class="directive">const</span> &amp; )
  {
    std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Bad command line argument</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
    <span class="keyword">return</span> <span class="integer">1</span>;
  }
  <span class="keyword">catch</span>( input_file_open_error <span class="directive">const</span> &amp; ex )
  {
    handle_exception( exp, ex, <i class="conum" data-value="3"></i><b>(3)</b>

      leaf::match&lt;e_file_name, e_errno&gt;( [ ] ( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
      {
        <span class="keyword">if</span>( errn==ENOENT )
          std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File not found: </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; std::endl;
        <span class="keyword">else</span>
          std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to open </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      } )

    );
    <span class="keyword">return</span> <span class="integer">2</span>;
  }
  <span class="keyword">catch</span>( input_error <span class="directive">const</span> &amp; ex )
  {
    handle_exception( exp, ex, <i class="conum" data-value="4"></i><b>(4)</b>

      leaf::match&lt;e_file_name, e_errno&gt;( [ ] ( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
      {
        std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Input error, </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      } ),

      leaf::match&lt;e_errno&gt;( [ ] ( <span class="predefined-type">int</span> errn )
      {
        std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Input error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      } ),

      leaf::match&lt;&gt;( [ ]
      {
        std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Input error</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
      } )

    );
    <span class="keyword">return</span> <span class="integer">3</span>;
  }
  <span class="keyword">catch</span>( std::ostream::failure <span class="directive">const</span> &amp; ex )
  {
    <span class="comment">//Report failure to write to std::cout, print the relevant errno, if available.</span>
    handle_exception( exp, ex,

      leaf::match&lt;e_errno&gt;( [ ] ( <span class="predefined-type">int</span> errn )
      {
        std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Output error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
      } )

    );
    <span class="keyword">return</span> <span class="integer">4</span>;
  }
  <span class="keyword">catch</span>(...) <i class="conum" data-value="5"></i><b>(5)</b>
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown error, cryptic information follows.</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;
    current_exception_diagnostic_output(std::cerr,exp);
    <span class="keyword">return</span> <span class="integer">5</span>;
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Configure <code>std::cout</code> to throw on error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We expect <code>e_file_name</code> and <code>e_errno</code> objects to arrive with errors handled in this function. They will be stored inside <code>exp</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code><a href="#handle_exception">handle_exception</a></code> takes a list of match objects (in this case only one), each given a set of <a href="#e-types">e-types</a>. It attempts to match each set (in order) to objects of e-types, associated with <code>ex</code>, available in <code>exp</code>. If no set can be matched, <code>handle_exception</code> rethrows the current exception. When a match is found,
<code>handle_exception</code> calls the corresponding lambda, passing the <code>.value</code> of each of the e-types from the matched set.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In this case <code>handle_exception</code> is given 3 match sets. It will first check if both <code>e_file_name</code> and <code>e_errno</code>, associated with <code>ex</code>, are avialable in <code>exp</code>; if not, it will next check if just <code>e_errno</code> is available; and if not, the last (empty) set will always match to print a generic error message.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This catch-all is designed to help diagnose logic errors (main should be able to deal with any failures).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>To summarize, when using LEAF with exception handling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In case a function detects a failure, it may use <code><a href="#throw_exception">throw_exception</a></code>, passing (in addition to the exception object) any number of <a href="#e-types">e-type</a> objects, to associate with the exception any information it has that is relevant to the failure. Alternatively it may use <code><a href="#preload">preload</a></code> to associate <a href="#e-types">e-type</a> objects with any exception thrown later on, including exceptions thrown by third-party code.</p>
</li>
<li>
<p>In order for any e-type object passed to <code><a href="#throw_exception">throw_exception</a></code> to be stored rather than discarded, the function that catches the exception must contain an instance of the class template <code><a href="#expect">expect</a></code> that provides the necessary storage for its type.</p>
</li>
<li>
<p>Using <code><a href="#handle_exception">handle_exception</a></code>, available <a href="#e-types">e-type</a> objects associated with the exception being handled can be matched to what is required in order to deal with that exception.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The complete program from this tutorial is available <a href="https://github.com/zajo/leaf/blob/master/example/print_file_eh.cpp?ts=3">here</a>. There is also <a href="https://github.com/zajo/leaf/blob/master/example/print_file_result.cpp?ts=3">another</a> version of the same program that does not use exception handling to report errors (see <a href="#tutorial-noexcept">previous tutorial</a>).
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="e-types">e-types</h3>
<div class="paragraph">
<p>With LEAF, users can efficiently associate with errors or with exceptions any number of values that pertain to a failure. Each such value is enclosed in a C-<code>struct</code>, which acts as its compile-time identifier and gives it semantic meaning. Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_input_name { std::<span class="predefined-type">string</span> value; };

<span class="keyword">struct</span> e_output_name { std::<span class="predefined-type">string</span> value; };

<span class="keyword">struct</span> e_minimum_temperature { <span class="predefined-type">int</span> value; };

<span class="keyword">struct</span> e_maximum_temperature { <span class="predefined-type">int</span> value; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>This text refers to such types as e-types because, by convention, they use the <code>e_</code> prefix. Similarly, instances of e-types are called e-objects.</p>
</div>
<div class="paragraph">
<p>The formal requirements for e-types are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They must define an accessible data member <code>value</code>, and</p>
</li>
<li>
<p>They must be movable, and the move constructor may not throw.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>LEAF itself never creates e-objects and generally only moves the e-objects it is given. Therefore, users are free to define any constructors as needed to enforce invariants for their e-types, but the typical case is to simply enclose a <code>value</code> in a C-<code>struct</code>.</p>
</div>
<div class="paragraph">
<p>Various functions in LEAF take a list of e-objects to associate with an <code><a href="#error">error</a></code> value. For example, to indicate an error, a function that returns a <code><a href="#result">result</a>&lt;T&gt;</code> may use something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">return</span> leaf::error( e_error_code{<span class="integer">42</span>}, e_input_name{n1}, e_output_name{n2} );</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Diagnostic Information</strong></p>
</div>
<div class="paragraph">
<p>LEAF will attempt to print e-objects in various <code>diagnostic_output</code> overloads it defines. It will first attempt to use <code>operator&lt;&lt;</code> overload that takes the enclosing <code>struct</code>. If such overload does not exist, the fallback is to attempt to use <code>operator&lt;&lt;</code> overload that takes the <code>.value</code>. If that also doesn&#8217;t exist, LEAF is unable to print values of that particular e-type (this is permissible, not an error).</p>
</div>
<div class="paragraph">
<p>The <code>diagnostic_output</code> functions in LEAF can use the e-types defined in the snippet above by default, because <code>int</code> and <code>std::string</code> values are printable. But even with printable values, the user may still want to overload <code>operator&lt;&lt;</code> for the enclosing <code>struct</code>, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_errno
{
  <span class="predefined-type">int</span> value;

  <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_errno <span class="directive">const</span> &amp; e )
  {
    <span class="keyword">return</span> os &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">errno = </span><span class="delimiter">&quot;</span></span> &lt;&lt; e.value &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> &lt;&lt; strerror(e.value) &lt;&lt; <span class="char">'&quot;'</span>;
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_errno</code> type above is designed to hold <code>errno</code> values. The defined <code>operator&lt;&lt;</code> overload will automatically include the output from <code>strerror</code> when <code>e_errno</code> values are printed by <code>diagnostic_output</code> overloads (LEAF defines <code>e_errno</code> in <code>&lt;boost/leaf/common.hpp&gt;</code>, together with other commonly-used e-types).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The output from <code>diagnostic_output</code> overloads is developer-friendly but not user-friendly. Therefore, <code>operator&lt;&lt;</code> overloads for e-types should only print technical information in English, and should not attempt to localize strings or to format a message. Formatting a localized user-friendly message should be done at the time individual errors are handled.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="expect">Class Template <code>expect</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="keyword">class</span> <span class="class">expect</span>
  {
  <span class="directive">public</span>:

    expect() <span class="directive">noexcept</span>;
    ~expect() <span class="directive">noexcept</span>;

    <span class="directive">void</span> propagate() <span class="directive">noexcept</span>;

    <span class="directive">friend</span> error_capture capture( expect &amp; exp, error <span class="directive">const</span> &amp; e );
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span><span class="error">.</span>.. M&gt;
  <span class="predefined-type">bool</span> handle_error( expect&lt;E...&gt; &amp; exp, error <span class="directive">const</span> &amp; e, M &amp;&amp; ... m ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>,<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, error <span class="directive">const</span> &amp; e ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, error <span class="directive">const</span> &amp; e );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified-type&gt; match( F &amp;&amp; f ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified-type&gt; match() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>All <code>expect&lt;E&#8230;&#8203;&gt;</code> objects must use automatic storage duration. They are not copyable and are not movable.</p>
</div>
<div class="paragraph">
<p>The specified <code>E&#8230;&#8203;</code> types must be user-defined (e.g. structs), with <code>noexcept</code> move semantics, that define accessible data member called <code>value</code>. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_file_name { std::<span class="predefined-type">string</span> value; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this text such types are referred to as <a href="#e-types">e-types</a>, because by convention they use the <code>e_</code> prefix. Similarly, instances of e-types are called e-objects.</p>
</div>
<div class="paragraph">
<p>An <code>expect&lt;E&#8230;&#8203;&gt;</code> object contains exactly <code>sizeof&#8230;&#8203;(E)</code> <em>slots</em>, each slot providing storage for a single object of the corresponding type <code>E</code>.  It is invalid to specify the same type more than once in <code>E&#8230;&#8203;</code>; so, each type <code>E</code> uniquely identifies an <code>expect</code> slot. All slots are initially empty.</p>
</div>
<div class="paragraph">
<p>Slots of the same type <code>E</code> across different <code>expect</code> objects (that belong to the calling thread)  form a stack. The slot created last for a given type <code>E</code> is at the top of that stack. When an <a href="#e-types">e-object</a> is passed to the <code>leaf::<a href="#error">error</a></code> constructor, it is moved into the corresponding slot on the top of that stack, and is associated with that <code>leaf::error</code> value. If no <code>expect</code> objects contain a corresponding slot, the e-object passed to the <code>leaf::error</code> constructor is discarded.</p>
</div>
<div class="paragraph">
<p>An e-object stored in an <code>expect</code> slot can be accessed in several different ways, all requiring the <code>leaf::error</code> value it was associated with. While an <code>expect</code> object can not store multiple values of the same e-type, this association guarantees that the returned e-object pertains to that specific <code>error</code> value.</p>
</div>
<div class="paragraph">
<p>Iff an error was successfully handled (a call to <code><a href="#handle_error-expect">handle_error</a></code> returned <code>true</code>), then <code>~expect</code> discards all e-objects stored in <code>*this</code>. Otherwise, each stored e-object is moved to the corresponding slot one level below the top of the stack formed by the slots of the same e-type across different <code>expect</code> objects. If that stack is empty, the e-object is discarded.</p>
</div>
<hr>
<div class="sect3">
<h4 id="expect::expect">Constructor</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  expect&lt;E...&gt;::expect() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Description: </dt>
<dd>
<p>Initializes an empty <code>expect</code> instance.</p>
</dd>
<dt class="hdlist1">Postcondition: </dt>
<dd>
<p><code><a href="#peek-expect">peek</a>&lt;P&gt;(*this,e)</code> returns <code>0</code> for any <code>P</code> and any <code><a href="#error">error</a></code> value <code>e</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="expect-dtor">Destructor</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  expect&lt;E...&gt;::~expect() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>By default, each stored <a href="#e-types">e-object</a> is moved to a corresponding slot in other existing <code>expect</code> instances according to the rules described <code><a href="#expect">here</a></code>, but if a call to <code><a href="#handle_error-expect">handle_error</a></code> for <code>*this</code> has succeeded, all objects currently stored in <code>*this</code> are discarded.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A call to <code><a href="#expect::propagate">propagate</a></code> restores the default behavior of <code>~expect</code> after a successful call to <code>handle_error</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="expect::propagate"><code>propagate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> expect&lt;E...&gt;::propagate() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>This function can be used to restore the default behavior of <code><a href="#expect-dtor">~expect</a></code> after a successful call to <code><a href="#handle_error-expect">handle_error</a></code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="capture-expect"><code>capture</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  error_capture capture( expect&lt;E...&gt; &amp; exp, error <span class="directive">const</span> &amp; e );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Moves all <a href="#e-types">e-objects</a> currently stored in <code>exp</code> and associated with the <code>leaf::<a href="#error">error</a></code> value <code>e</code>, into the returned <code><a href="#error_capture">error_capture</a></code> object. The contents of the <code>error_capture</code> object is immutable and allocated on the heap.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>error_capture</code> objects are useful for transporting e-objects to a different thread.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="match"><code>match</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified-type&gt; match( F &amp;&amp; f ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified-type&gt; match() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <code><a href="#handle_error-expect"><code>handle_error</code></a></code> below.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="handle_error-expect"><code>handle_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span><span class="error">.</span>.. M&gt;
  <span class="predefined-type">bool</span> handle_error( expect&lt;E...&gt; &amp; exp, error <span class="directive">const</span> &amp; e, M &amp;&amp; ... m ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>m&#8230;&#8203;</code> objects must have been obtained by a separate call to the function template <code><a href="#match">match</a></code>, each time instantiated with a different set of <a href="#e-types">e-types</a>, and passed a different function.<br></p>
<div class="paragraph">
<p>The call to <code>handle_error</code> attempts to match the set of e-types from each of the <code>m&#8230;&#8203;</code> objects, in order, to the types of <a href="#e-types">e-objects</a>, associated with the <code><a href="#error">error</a></code> value <code>e</code>, currently stored in <code>exp</code>.<br></p>
</div>
<div class="paragraph">
<p>If a complete match is found among <code>m&#8230;&#8203;</code>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Its function is called with the <code>.value</code> members of the entire set of matching e-objects from <code>exp</code> (the function may not modify those values);</p>
</li>
<li>
<p><code>exp</code> is marked so that <code><a href="#expect-dtor">~expect</a></code> will destroy all of the stored e-objects (this can be undone by a later call to <code><a href="#expect::propagate">propagate</a></code>);</p>
</li>
<li>
<p><code>handle_error</code> returns true.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Otherwise, <code>handle_error</code> returns false and <code>exp</code> is not modified.</p>
</div>
</dd>
<dt class="hdlist1">Example: </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">bool</span> matched = handle_error( exp, e,

  leaf::match&lt;e_file_name,e_errno&gt;( [ ] ( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to access </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
  } ),

  leaf::match&lt;e_errno&gt;( [ ] ( <span class="predefined-type">int</span> errn )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I/O error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
  } )

);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming <code>struct e_file_name { std::string value; }</code> and <code>struct e_errno { int value; }</code>, the call to <code>handle_error</code> above will:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check if the <code>expect</code> object <code>exp</code> contains <code>e_file_name</code> and <code>e_errno</code> objects, associated with the <code>leaf::<a href="#error">error</a></code> value <code>e</code>. If it does, it will pass them to the lambda function passed in the first call to <code><a href="#match">match</a></code>, then return <code>true</code>;</p>
</li>
<li>
<p>Otherwise if it contains just <code>e_errno</code>, it will pass it to the lambda function passed in the second call to <code>match</code>, then return <code>true</code>;</p>
</li>
<li>
<p>Otherwise, <code>handle_error</code> returns <code>false</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="peek-expect"><code>peek</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>,<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, error <span class="directive">const</span> &amp; e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>exp</code> currently stores an object of type <code>P</code> associated with the <code><a href="#error">error</a></code> value <code>e</code>, returns a read-only pointer to that object. Otherwise returns <code>0</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diagnostic_output-expect"><code>diagnostic_output</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/expect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, error <span class="directive">const</span> &amp; e );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Prints diagnostic information about the <a href="#e-types">e-type</a> objects stored in <code>exp</code>. The second overload will only print diagnostic information about e-objects stored in <code>exp</code> which are associated with the <code>leaf::<a href="#error">error</a></code> value <code>e</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The printing of each individual e-object is done by the rules described <a href="#e-types">here</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="error">Class <code>error</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">error</span>
  {
  <span class="directive">public</span>:

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    <span class="directive">explicit</span> error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>:

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    error propagate( E &amp;&amp; ... e ) <span class="directive">const</span> <span class="directive">noexcept</span>;

    <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>==( error <span class="directive">const</span> &amp; e1, error <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;
    <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>!=( error <span class="directive">const</span> &amp; e1, error <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, error <span class="directive">const</span> &amp; e )

    <span class="directive">static</span> error peek_next_error() <span class="directive">noexcept</span>;
  };

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Objects of class <code>error</code> are values that identify a errors across the entire program. They can be copied, moved, assigned to, and compared to other error objects. They occupy as much memory as <code>unsigned int</code>, and are as fast.</p>
</div>
<div class="paragraph">
<p>Whenever an <code>e&#8230;&#8203;</code> sequence is passed <code>error</code> functions, these objects are moved into matching storage provided by <code><a href="#expect">expect</a></code> instances and associated with the <code>error</code> object, which can later be passed to <code><a href="#peek-expect">peek</a></code> or <code><a href="#handle_error-expect">handle_error</a></code> to retrieve them.</p>
</div>
<hr>
<div class="sect3">
<h4 id="error::error">Constructor</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">explicit</span> error::error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>e&#8230;&#8203;</code> objects is either moved into the corresponding storage provided by <code>expect</code> instances or discarded. See <code><a href="#expect">expect</a></code>.</p>
</dd>
<dt class="hdlist1">Postconditions: </dt>
<dd>
<p><code>*this</code> is a unique value across the entire program. The user may create any number of other <code>error</code> values that compare equal to <code>*this</code>, by copy, move or assignment, just like with any other value type.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error::propagate"><code>propagate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    error error::propagate( E &amp;&amp; ... e ) <span class="directive">const</span> <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>e&#8230;&#8203;</code> objects is either moved into the corresponding storage provided by <code>expect</code> instances and associated with <code>*this</code>; or discarded. See <code><a href="#expect">expect</a></code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="operator_eq-error"><code>operator==</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>==( error <span class="directive">const</span> &amp; e1, error <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if the two values <code>e1</code> and <code>e2</code> are equal, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="operator_neq-error"><code>operator!=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="directive">friend</span> <span class="predefined-type">bool</span> <span class="directive">operator</span>!=( error <span class="directive">const</span> &amp; e1, error <span class="directive">const</span> &amp; e2 ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>!(e1==e2)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="operator_shl-error"><code>operator&lt;&lt;</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, error <span class="directive">const</span> &amp; e )

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Prints an <code>unsigned int</code> value that uniquely identifies the value <code>e</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error::peek_next_error"><code>peek_next_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error error::peek_next_error() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The <code>error</code> value which will be returned the next time the <code><a href="#error::error">error</a></code> constructor is invoked from the calling thread.</p>
<div class="paragraph">
<p>This function can be used to associate <a href="#e-types">e-objects</a> with the next <code>error</code> value to be reported. Use with caution, only when restricted to reporting errors using specific types, incompatible with LEAF, for example in a C callback. As soon as control exits this critical path, you should create and return a <code>leaf::error</code> object.</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>error</code> values are unique across the entire program.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="preload"><code>preload</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  &lt;&lt;unspecified-type&gt;&gt; preload( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>e&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="ulist">
<ul>
<li>
<p>If a new <code>leaf::<a href="#error">error</a></code> value was created (in the calling thread) since it was created, the stored <code>e&#8230;&#8203;</code> objects are propagated and become associated with  the <em>first</em> <code>leaf::error</code> value created after <code>preload</code> was called;</p>
</li>
<li>
<p>Otherwise, the stored <code>e&#8230;&#8203;</code> objects are discarded.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="defer"><code>defer</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. F&gt;
  &lt;&lt;unspecified-type&gt;&gt; defer( F &amp;&amp; ... f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p>All <code>f&#8230;&#8203;</code> objects must be functions that do not throw exceptions, take no arguments and return an <a href="#e-types">e-type</a> object.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>f&#8230;&#8203;</code> objects are forwarded and stored into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed:</p>
<div class="ulist">
<ul>
<li>
<p>If a new <code>leaf::<a href="#error">error</a></code> value was created (in the calling thread) since it was created, each of the stored <code>f&#8230;&#8203;</code> is called, and the returned <a href="#e-types">e-value</a> is propagated and becomes associated with  the <em>first</em> <code>leaf::error</code> value created after <code>defer</code> was called;</p>
</li>
<li>
<p>Otherwise, the stored <code>f&#8230;&#8203;</code> objects are discarded.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="error_capture">Class <code>error_capture</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">class</span> <span class="class">error_capture</span>
  {
  <span class="directive">public</span>:

    error_capture() <span class="directive">noexcept</span>;

    <span class="directive">explicit</span> <span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

    error unload() <span class="directive">noexcept</span>;
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. M&gt;
  <span class="predefined-type">bool</span> handle_error( error_capture <span class="directive">const</span> &amp; ec, M &amp;&amp; ... m ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( error_capture <span class="directive">const</span> &amp; ec ) <span class="directive">noexcept</span>;

  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, error_capture <span class="directive">const</span> &amp; ec );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Objects of class <code>error_capture</code> are similar to <code><a href="#expect">expect</a></code> instances in that they contain <a href="#e-types">e-objects</a> and can be examined by (their own overloads of) <code><a href="#peek-error_capture">peek</a></code> and <code><a href="#handle_error-error_capture">handle_error</a></code>. However, unlike <code>expect</code> objects, <code>error_capture</code> objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are immutable;</p>
</li>
<li>
<p>are allocated on the heap;</p>
</li>
<li>
<p>associate all of their e-objects with exactly one <code>error</code> value;</p>
</li>
<li>
<p>when probed with <code>peek</code>/<code>handle_error</code>, the lookup is dynamic;</p>
</li>
<li>
<p>define <code>noexcept</code> copy/move/assignment operations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default constructor can be used to initialize an empty <code>error_capture</code>. Use <code><a href="#capture-expect">capture</a></code> to capture all e-objects associated with a given <code>error</code> value from a given <code>expect</code> object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Typical use of <code>error_capture</code> objects is to transport e-objects across threads, however they are rarely used directly. Instead:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With exception handling, use <code><a href="#capture_exception">capture_exception</a></code> / <code><a href="#get">get</a></code>;</p>
</li>
<li>
<p>Without exception handling, simply return a <a href="#capture-result">captured</a> <code>result&lt;T&gt;</code> from a worker thread.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="error_capture::error_captere">Constructor</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error_capture::error_capture() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Effects: Initializes an empty <code>error_capture</code> instance.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Postcondition: </dt>
<dd>
<p><code><a href="#peek-error_capture">peek</a>&lt;P&gt;(*this,e)</code> returns <code>0</code> for any <code>P</code> and any <code><a href="#error">error</a></code> value <code>e</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_capture::operator_bool">Conversion to <code>bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error_capture::<span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>false</code> if <code>*this</code> is empty, <code>true</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_capture::unload"><code>unload</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error error_capture::unload() <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The <a href="#e-types">e-types</a> stored in <code>*this</code> are moved into storage provided by <code><a href="#expect">expect</a></code> objects in the calling thread, as if each e-object is passed to the constructor of <code><a href="#error">error</a></code>.</p>
</dd>
<dt class="hdlist1">Postcondition: </dt>
<dd>
<p><code>!(*this)</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="handle_error-error_capture"><code>handle_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. M&gt;
  <span class="directive">friend</span> <span class="predefined-type">bool</span> error_capture::handle_error( error_capture <span class="directive">const</span> &amp; ec, M &amp;&amp; ... m ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each of the <code>m&#8230;&#8203;</code> objects must have been obtained by a separate call to the function template <code><a href="#match">match</a></code>, each time instantiated with a different set of <a href="#e-types">e-types</a>, and passed a different function.<br></p>
<div class="paragraph">
<p>The call to <code>handle_error</code> attempts to match the set of e-types from each of the <code>m&#8230;&#8203;</code> objects, in order, to the types of <a href="#e-types">e-objects</a> currently stored in <code>ec</code>.<br></p>
</div>
<div class="paragraph">
<p>If a complete match is found among <code>m&#8230;&#8203;</code>:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Its function is called with the <code>.value</code> members of the entire set of matching e-objects from <code>ec</code> (the function may not modify those values);</p>
</li>
<li>
<p><code>handle_error</code> returns true.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Otherwise, <code>handle_error</code> returns false.</p>
</div>
</dd>
<dt class="hdlist1">Example: </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">bool</span> matched = handle_error( ec,

  leaf::match&lt;e_file_name,e_errno&gt;( [ ] ( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Failed to access </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
  } ),

  leaf::match&lt;e_errno&gt;( [ ] ( <span class="predefined-type">int</span> errn )
  {
    std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I/O error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; std::endl;
  } )

);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming <code>struct e_file_name { std::string value; }</code> and <code>struct e_errno { int value; }</code>, the call to <code>handle_error</code> above will:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check if the <code>error_capture</code> object <code>ec</code> contains <code>e_file_name</code> and <code>e_errno</code> objects. If it does, it will pass them to the lambda function passed in the first call to <code><a href="#match">match</a></code>, then return <code>true</code>;</p>
</li>
<li>
<p>Otherwise if it contains just <code>e_errno</code>, it will pass it to the lambda function passed in the second call to <code>match</code>, then return <code>true</code>;</p>
</li>
<li>
<p>Otherwise, <code>handle_error</code> returns <code>false</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="peek-error_capture"><code>peek</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( error_capture <span class="directive">const</span> &amp; ec ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>ec</code> currently stores an object of type <code>P</code>, returns a read-only pointer to that object. Otherwise returns <code>0</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diagnostic_output-error_capture"><code>diagnostic_output</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="directive">friend</span> <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, error_capture <span class="directive">const</span> &amp; ec );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Prints diagnostic information about the <a href="#e-types">e-type</a> objects stored in <code>ec</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The printing of each individual e-object is done by the rules described <a href="#e-types">here</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="result">Class template <code>result</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
  result
  {
  <span class="directive">public</span>:

    result() <span class="directive">noexcept</span>;
    result( T <span class="directive">const</span> &amp; v );
    result( T &amp;&amp; v ) <span class="directive">noexcept</span>;
    result( leaf::error <span class="directive">const</span> &amp; e ) <span class="directive">noexcept</span>;
    result( leaf::error_capture <span class="directive">const</span> &amp; ec ) <span class="directive">noexcept</span>;

    <span class="directive">explicit</span> <span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

    T <span class="directive">const</span> &amp; value() <span class="directive">const</span>;
    T &amp; value();
    T <span class="directive">const</span> &amp; <span class="directive">operator</span>*() <span class="directive">const</span>;
    T &amp; <span class="directive">operator</span>*();

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    leaf::error error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
    <span class="directive">friend</span> result capture( expect&lt;E...&gt; &amp; exp, result <span class="directive">const</span> &amp; r );

 };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">T</span>,<span class="keyword">class</span><span class="error">.</span>.. M&gt;
  <span class="predefined-type">bool</span> handle_error( expect&lt;E...&gt; &amp; exp, result&lt;T&gt; &amp; r, M &amp;&amp; ... m ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>,<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( expect&lt;E...&gt; <span class="directive">const</span> &amp;, result&lt;T&gt; <span class="directive">const</span> &amp; ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="directive">friend</span> <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, result&lt;T&gt; <span class="directive">const</span> &amp; r );

  <span class="keyword">struct</span> bad_result: std::exception { };

} }

<span class="preprocessor">#define</span> LEAF_AUTO(v,r) <span class="directive">auto</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> = r; <span class="keyword">if</span>( !_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> ) <span class="keyword">return</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span>.error(); <span class="directive">auto</span> &amp; v = *_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span>
<span class="preprocessor">#define</span> LEAF_CHECK(r) {<span class="directive">auto</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> = r; <span class="keyword">if</span>( !_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> ) <span class="keyword">return</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span>.error();}</code></pre>
</div>
</div>
</div>
</div>
<hr>
<div class="sect3">
<h4 id="result::result">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  result::result() <span class="directive">noexcept</span>;
  result::result( T <span class="directive">const</span> &amp; v );
  result::result( T &amp;&amp; v ) <span class="directive">noexcept</span>;
  result::result( leaf::error <span class="directive">const</span> &amp; e ) <span class="directive">noexcept</span>;
  result::result( leaf::error_capture <span class="directive">const</span> &amp; ec ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>result&lt;T&gt;</code> object is in one of two states:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Value state, in which case it contains an object of type <code>T</code>, and <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code> can be used to access the contained value.</p>
</li>
<li>
<p>Error state, in which case it contains an object of type <code><a href="#error">error</a></code> or an object of type <code><a href="#error_capture">error_capture</a></code>, and calling <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code> throws <code>leaf::<a href="#bad_result">bad_result</a></code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To get a <code>result&lt;T&gt;</code> object in error state, initialize it with a <code>leaf::error</code> or a <code>leaf::error_capture</code> .</p>
</div>
<div class="paragraph">
<p>Otherwise a <code>result&lt;T&gt;</code> is initialized in value state using the default constructor of <code>T</code>, or by copying or moving from <code>v</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>result</code> that is in value state converts to <code>true</code> in boolean contexts. A <code>result</code> that is in error state converts to <code>false</code> in boolean contexts.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_bool">Conversion to <code>bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  result::<span class="directive">operator</span> <span class="predefined-type">bool</span>() <span class="directive">const</span> <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>*this</code> was initialized in value state, returns <code>true</code>, otherwise returns <code>false</code>. See <code><a href="#result::result">Constructors</a></code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::value"><code>value</code>/<code>operator*</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  T <span class="directive">const</span> &amp; result::value() <span class="directive">const</span>;
  T &amp; result::value();
  T <span class="directive">const</span> &amp; result::<span class="directive">operator</span>*() <span class="directive">const</span>;
  T &amp; result::<span class="directive">operator</span>*();

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>*this</code> was initialized in value state, returns a reference to the stored value, otherwise throws <code>leaf::<a href="#bad_result">bad_result</a></code>. See <code><a href="#result::result">Constructors</a></code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::error"><code>error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  leaf::error result::error( E &amp;&amp; ... e ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This member function is designed to be used in <code>return</code> statements in functions that return <code>result&lt;T&gt;</code> (or <code>leaf::<a href="#error">error</a></code>) to return an error to the caller.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in value state, returns <code>leaf::<a href="#error::error">error</a>(std::forward&lt;E&gt;(e&#8230;&#8203;))</code>, which begins propagating a new <code>error</code> value (as opposed to forwarding an existing <code>error</code> value);</p>
</li>
<li>
<p>If <code>*this</code> is in error state, it stores either an <code><a href="#error_capture">error_capture</a></code> or a <code>leaf::<a href="#error">error</a></code>:</p>
<div class="ulist">
<ul>
<li>
<p>if <code>*this</code> stores an <code><a href="#error_capture">error_capture</a> cap</code>, <code>*this</code> is converted to store the <code>leaf::<a href="#error">error</a></code> value returned from <code>cap.<a href="#error_capture::unload">unload</a>()</code>, then</p>
</li>
<li>
<p>if <code>*this</code> stores a <code>leaf::error</code> value <code>err</code>, returns <code>err.<a href="#error::propagate">propagate</a>(std::forward&lt;E&gt;(e&#8230;&#8203;))</code>, which forwards the same <code>error</code> to the caller, augmenting it with the additional <a href="#e-types">e-type</a> objects <code>e&#8230;&#8203;</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="capture-result"><code>capture</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">friend</span> result result::capture( expect&lt;E...&gt; &amp; exp, result <span class="directive">const</span> &amp; r );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in value state, returns <code>*this</code>.</p>
</li>
<li>
<p>If <code>*this</code> is in error state and stores an <code><a href="#error_capture">erorr_capture</a></code> object, returns <code>*this</code>.</p>
</li>
<li>
<p>If <code>*this</code> is in error state and stores a <code>leaf::<a href="#error">error</a></code> value <code>err</code>, returns <code><a href="#capture-expect">capture</a>(exp,err)</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For an example, see <a href="#technique_transport-result">Transporting Errors between Threads using <code>result&lt;T&gt;</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="handle_error-result"><code>handle_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">T</span>,<span class="keyword">class</span><span class="error">.</span>.. M&gt;
  <span class="directive">friend</span> <span class="predefined-type">bool</span> result::handle_error( expect&lt;E...&gt; &amp; exp, result&lt;T&gt; &amp; r, M &amp;&amp; ... m ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code>!r</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>r</code> stores an <code><a href="#error_capture">error_capture</a></code> object <code>cap</code>, returns <code><a href="#handle_error-error_capture">handle_error</a>&lt;E&#8230;&#8203;&gt;(cap,m&#8230;&#8203;)</code>.</p>
</li>
<li>
<p>If <code>r</code> stores a <code>leaf::<a href="#error">error</a></code> value <code>err</code>, returns <code><a href="#handle_error-expect">handle_error</a>&lt;E&#8230;&#8203;&gt;(exp,err,m&#8230;&#8203;)</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="peek-result"><code>peek</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>,<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, result&lt;T&gt; <span class="directive">const</span> &amp; r ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code>!r</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>r</code> stores an <code><a href="#error_capture">error_capture</a></code> object <code>cap</code>, returns <code><a href="#peek-error_capture">peek</a>&lt;P&gt;(cap)</code>.</p>
</li>
<li>
<p>If <code>r</code> stores a <code>leaf::<a href="#error">error</a></code> value <code>err</code>, returns <code><a href="#peek-expect">peek</a>&lt;P&gt;(exp,err)</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diagnostic_output-result"><code>diagnostic_output</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">T</span>&gt;
  <span class="directive">friend</span> <span class="directive">void</span> result::diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, result&lt;T&gt; <span class="directive">const</span> &amp; r );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions: </dt>
<dd>
<p><code>!r</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>r</code> stores an <code><a href="#error_capture">error_capture</a></code> object <code>cap</code>, returns <code><a href="#diagnostic_output-error_capture">diagnostic_output</a>(os,cap)</code>.</p>
</li>
<li>
<p>If <code>r</code> stores a <code>leaf::<a href="#error">error</a></code> value <code>err</code>, returns <code><a href="#diagnostic_output-expect">diagnostic_output</a>(os,exp,err)</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="bad_result"><code>bad_result</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> bad_result: std::exception { };

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This exception is thrown by <code><a href="#result::value">value</a>()</code>/<code><a href="#result::value">operator*</a>()</code> if they`re invoked for a <code>result</code> object that is in error state.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="LEAF_AUTO"><code>LEAF_AUTO</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_AUTO(v,r) <span class="directive">auto</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> = r; <span class="keyword">if</span>( !_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> ) <span class="keyword">return</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span>.error(); <span class="directive">auto</span> &amp; v = *_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="LEAF_CHECK"><code>LEAF_CHECK</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_CHECK(r) {<span class="directive">auto</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> = r; <span class="keyword">if</span>( !_r_<span class="preprocessor">#</span><span class="preprocessor">#v</span> ) <span class="keyword">return</span> _r_<span class="preprocessor">#</span><span class="preprocessor">#v</span>.error();}</code></pre>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="eh">Exception Handling Functions</h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_THROW(e) ::boost::leaf::throw_exception(e,LEAF_SOURCE_LOCATION)

<span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">Ex</span>&gt;
  [[noreturn]] <span class="directive">void</span> throw_exception( Ex &amp;&amp; ex, E &amp;&amp; ... e );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">Ex</span>&gt;
  [[noreturn]] <span class="directive">void</span> throw_exception( Ex &amp;&amp; ex, error <span class="directive">const</span> &amp; err, E &amp;&amp; ... e );

  error get_error( std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>,<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. M,<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> handle_exception( expect&lt;E...&gt; &amp; exp, std::exception <span class="directive">const</span> &amp; ex, M &amp;&amp; ... m );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, std::exception <span class="directive">const</span> &amp; ex );

} }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception_capture.hpp&gt;</div>
<div class="content">
<pre class="nowrap">namespace boost { namespace leaf {

  template &lt;class... E,class F&gt;
  &lt;&lt;unspecified-type&gt;&gt; capture_exception( F &amp;&amp; f ) noexcept;

  template &lt;class Future&gt;
  decltype(std::declval&lt;Future&gt;().get()) get( Future &amp;&amp; f );

} }</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The two headers <code>&lt;boost/leaf/exception.hpp&gt;</code> and <code>&lt;boost/leaf/exception_capture&gt;</code> define functions designed for programs that use exception handling.</p>
</div>
<hr>
<div class="sect3">
<h4 id="throw_exception"><code>throw_exception</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_THROW(e) ::boost::leaf::throw_exception(e,LEAF_SOURCE_LOCATION)

<span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">Ex</span>&gt;
  [[noreturn]] <span class="directive">void</span> throw_exception( Ex &amp;&amp; ex, E &amp;&amp; ... e );

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">Ex</span>&gt;
  [[noreturn]] <span class="directive">void</span> throw_exception( Ex &amp;&amp; ex, error <span class="directive">const</span> &amp; err, E &amp;&amp; ... e );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>Ex</code> must derive from <code>std::exception</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The first overload throws an exception object of unspecified type which derives publicly from both <code>Ex</code> and <code>leaf::<a href="#error">error</a></code>, its <code>Ex</code> sub-object initialized by moing from <code>ex</code>, its <code>error</code> sub-object initialized by <code><a href="#error::error">error</a>(std::forward&lt;E&gt;(e&#8230;&#8203;))</code>;</p>
</li>
<li>
<p>The second overload throws an exception object of unspecified type which derives publicly from both <code>Ex</code> and <code>leaf::<a href="#error">error</a></code>, its <code>Ex</code> sub-object initialized by moing from <code>ex</code>, its <code>error</code> sub-object initialized by <code>err.<a href="#error::propagate">propagate</a>(std::forward&lt;E&gt;(e&#8230;&#8203;))</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The thrown exception object can be caught as <code>Ex &amp;</code> or as <code>leaf::<a href="#error">error</a></code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>LEAF_THROW</code> to automatically pass the current source location in an instance of <code><a href="#common">e_source_location</a></code> object to <code>throw_exception</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="capture_exception"><code>capture_exception</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E,<span class="keyword">class</span> <span class="class">F</span>&gt;
  &lt;&lt;unspecified-type&gt;&gt; capture_exception( F &amp;&amp; f ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For an, example see <a href="#technique_transport-exceptions">Transporting Errors between Threads using Exception Handling</a>.
</td>
</tr>
</table>
</div>
<hr>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>F</code> must be a function type.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A function of unspecified type which wraps <code>f</code> and, when called, forwards all its arguments to <code>f</code>, capturing the specified <code>E&#8230;&#8203;</code> <a href="#e-types">e-types</a> in case it throws.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>capture_exception</code> function is designed for use with <code><a href="#get">get</a></code>, to effectively transport <a href="#e-types">e-objects</a> across thread boundaries.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="get"><code>get</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception_capture.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Future</span>&gt;
  <span class="directive">decltype</span>(std::declval&lt;Future&gt;().get()) get( Future &amp;&amp; f );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements: </dt>
<dd>
<p><code>Future</code> must be a <code>std::future</code> or other similar type used to recover future values by a member function <code>get()</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>f.get()</code>.</p>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>Any exception thrown by <code>f.get()</code>. If the future function was launched using <code><a href="#capture_exception">capture_exception</a>&lt;E&#8230;&#8203;&gt;</code>, all <code>E&#8230;&#8203;</code> type <a href="#e-types">e-objects</a> captured in the worker thread are transported to the calling thread.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To store and to access the transported <a href="#e-types">e-objects</a>, the calling thread must provide a suitable <code><a href="#expect">expect</a></code> object.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="get_error"><code>get_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  error get_error( std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>auto e = dynamic_cast&lt;leaf::<a href="#error">error</a> const *&gt;(&amp;ex)</code> succeeds, returns <code>*e</code>.</p>
</li>
<li>
<p>Othrewise, it returns an unspecified <code>leaf::error</code> value, which is "temporarily" associated with any and all currently unhandled exceptions.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A successful call to <code><a href="#handle_exception">handle_exception</a></code> breaks this association.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="handle_exception"><code>handle_exception</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. M,<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> handle_exception( expect&lt;E...&gt; &amp; exp, std::exception <span class="directive">const</span> &amp; ex, M &amp;&amp; ... m );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Equivalent to: <code>if( !<a href="#handle_error-expect">handle_error</a>( exp, <a href="#get_error">get_error</a>(ex), std::forward&lt;M&gt;(m)&#8230;&#8203;) ) throw;</code></p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In case the dynamic type of <code>ex</code> does not derive from <code>leaf::error</code> and the call to <code>handle_error</code> succeeds, the association between the <code>leaf::error</code> value returned by <code><a href="#get_error">get_error</a></code> and the currently unhandled exceptions is broken.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="peek-exception"><code>peek</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">P</span>,<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">decltype</span>(P::value) <span class="directive">const</span> * peek( expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, std::exception <span class="directive">const</span> &amp; ex ) <span class="directive">noexcept</span>;

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if <code>return leaf::<a href="#peek-expect">peek</a>&lt;P&gt;( exp, <a href="#get_error">get_error</a>(ex) );</code></p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="diagnostic_output-exception"><code>diagnostic_output</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span><span class="error">.</span>.. E&gt;
  <span class="directive">void</span> diagnostic_output( std::ostream &amp; os, expect&lt;E...&gt; <span class="directive">const</span> &amp; exp, std::exception <span class="directive">const</span> &amp; ex );

} }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Equivalent to: <code><a href="#diagnostic_output-expect">diagnostic_output</a>( os, exp, <a href="#get_error">get_error</a>(ex) );</code></p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="common">Common e-types</h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> LEAF_SOURCE_LOCATION ::boost::leaf::e_source_location{::boost::leaf::e_source_location::loc(__FILE__,__LINE__,__FUNCTION__)}

<span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> leaf {

  <span class="keyword">struct</span> e_api_function { <span class="predefined-type">char</span> <span class="directive">const</span> * value; };
  <span class="keyword">struct</span> e_file_name { std::<span class="predefined-type">string</span> value; };

  <span class="keyword">struct</span> e_errno
  {
    <span class="predefined-type">int</span> value;
    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_errno <span class="directive">const</span> &amp; err );
  };

  e_errno get_errno() <span class="directive">noexcept</span>
  {
    <span class="keyword">return</span> e_errno { errno };
  }

  <span class="keyword">struct</span> e_source_location
  {
    <span class="keyword">struct</span> loc
    {
      <span class="predefined-type">char</span> <span class="directive">const</span> * <span class="directive">const</span> file;
      <span class="predefined-type">int</span> <span class="directive">const</span> line;
      <span class="predefined-type">char</span> <span class="directive">const</span> * <span class="directive">const</span> function;
      loc( <span class="predefined-type">char</span> <span class="directive">const</span> * file, <span class="predefined-type">int</span> line, <span class="predefined-type">char</span> <span class="directive">const</span> * function ) <span class="directive">noexcept</span>;
    };
    loc value;

    <span class="directive">friend</span> std::ostream &amp; <span class="directive">operator</span>&lt;&lt;( std::ostream &amp; os, e_source_location <span class="directive">const</span> &amp; x );
  };

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This header defines some common <a href="#e-types">e-type</a> objects which can be used directly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>e_api_function</code> type is designed to capture the name of the function for which a failure is reported. For example, if you&#8217;re reporting an error detected by <code>fread</code>, you could use <code>leaf::e_api_function { "fread" }</code>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The passed value is stored as a C string, so you should only pass string literals for <code>value</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>When a file operation fails, you could use <code>e_file_name</code> to store the name of the file.</p>
</li>
<li>
<p><code>e_errno</code> is suitable to capture <code>errno</code>. <code>e_errno</code> objects use <code>strerror</code> to convert the <code>errno</code> code to a friendlier error message when <code><a href="#diagnostic_output-expect">diagnostic_output</a></code> is invoked.</p>
</li>
<li>
<p>The <code>LEAF_SOURCE_LOCATION</code> macro captures <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> into a <code>e_source_location</code> object.  When <code><a href="#diagnostic_output-expect">diagnostic_output</a></code> is invoked, all three items are printed.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="techniques">Programming Techniques</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="technique_preload">Preloading Errors</h3>
<div class="paragraph">
<p>Consider the following exception type:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">class</span> <span class="class">file_read_error</span>: <span class="directive">public</span> std::exception
{
  std::<span class="predefined-type">string</span> file_name_;

  <span class="directive">public</span>:

  <span class="directive">explicit</span> file_read_error( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn ): file_name_(fn) { }

  std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; file_name() <span class="directive">const</span> <span class="directive">noexcept</span> { <span class="keyword">return</span> file_name_; }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A catch statement that handles <code>file_read_error</code> exceptions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">catch</span>( file_read_error &amp; e )
{
  std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Error reading </span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> &lt;&lt; e.file_name() &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, a function that may throw <code>file_read_error</code> exceptions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file( FILE * f ) {
  ....
  size_t nr=fread(buf,<span class="integer">1</span>,count,f);
  <span class="keyword">if</span>( ferror(f) )
    <span class="keyword">throw</span> file_read_error(???); <span class="comment">//File name not available here!</span>
  ....
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is a problem: the <code>catch</code> needs a file name, but at the point of the <code>throw</code> a file name is not available (only a <code>FILE</code> pointer is). In general the error might be detected in a library which can not assume that a meaningful name is available for any <code>FILE</code> it reads, even if a program that uses the library could reasonably make the same assumption.</p>
</div>
<div class="paragraph">
<p>Using LEAF, a file name may be associated with any exception after it has been thrown, while anything available at the point of the <code>throw</code> (e.g. <code>errno</code>) may be passed directly to <code><a href="#throw_exception">throw_exception</a></code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">class</span> <span class="class">file_read_error</span>: <span class="directive">public</span> std::exception { };
<span class="keyword">struct</span> e_file_name { std::<span class="predefined-type">string</span> value; };
<span class="keyword">struct</span> e_errno { <span class="predefined-type">int</span> value; };

<span class="directive">void</span> read_file( FILE * f )
{
  ....
  size_t nr=fread( buf,<span class="integer">1</span>,count,f );
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error(), e_errno{errno} );
  ....
}

<span class="directive">void</span> process_file( <span class="predefined-type">char</span> <span class="directive">const</span> * name )
{
  <span class="directive">auto</span> propagate = leaf::preload( e_file_name{name} );

  <span class="keyword">if</span>( FILE * fp=fopen(name,<span class="string"><span class="delimiter">&quot;</span><span class="content">rt</span><span class="delimiter">&quot;</span></span>)) {
    std::shared_ptr&lt;FILE&gt; f(fp,fclose);
    ....
    read_file(fp); <span class="comment">//throws on error</span>
    ....
  }
  <span class="keyword">else</span>
    leaf::throw_exception( file_open_error() );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The key is the call to <code><a href="#preload">preload</a></code>: it gets the file name ready to be associated with any exception that escapes <code>process_file</code>. This is fully automatic, and works regardless of whether the exception is thrown later in the same function, or by <code>read_file</code>, or by some third-party function we call.</p>
</div>
<div class="paragraph">
<p>Now, the <code>try&#8230;&#8203;catch</code> that handles exceptions thrown by <code>process_file</code> may look like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::expect&lt;e_errno,e_file_name&gt; exp;
<span class="keyword">try</span>
{
  process_file(<span class="string"><span class="delimiter">&quot;</span><span class="content">example.txt</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">catch</span>( file_io_error &amp; e )
{
  std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">I/O error!</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;

  leaf::handle_exception( exp, e,
    leaf::match&lt;e_file_name,e_errno&gt;( [ ]( std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; fn, <span class="predefined-type">int</span> errn )
    {
      std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File name: </span><span class="delimiter">&quot;</span></span> &lt;&lt; fn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; errn &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
    } )
  );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This technique works exacly the same way when errors are reported using <code>leaf::<a href="#result">result</a></code> rather than by throwing exceptions.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_defer">Capturing <code>errno</code> with <code>defer</code></h3>
<div class="paragraph">
<p>Consider the following function:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file(FILE * f) {
  ....
  size_t nr=fread(buf,<span class="integer">1</span>,count,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error(), e_errno{errno} );
  ....
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is pretty straight-forward, reporting <code>e_errno</code> as it detects a <code>ferror</code>. But what if it calls <code>fread</code> multiple times?</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file(FILE * f) {
  ....
  size_t nr1=fread(buf1,<span class="integer">1</span>,count1,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error(), e_errno{errno} );

  size_t nr2=fread(buf2,<span class="integer">1</span>,count2,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error(), e_errno{errno} );

  size_t nr3=fread(buf3,<span class="integer">1</span>,count3,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error(), e_errno{errno} );
  ....
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ideally, associating <code>e_errno</code> with each exception should be automated. One way to achieve this is to not call <code>fread</code> directly, but wrap it in another function which checks for <code>ferror</code> and associates the <code>e_errno</code> with the exception it throws.</p>
</div>
<div class="paragraph">
<p><a href="#technique_preload">Preloading Errors</a> describes how to solve a very similar problem without a wrapper function, but that technique does not work for <code>e_errno</code> because <code><a href="#preload">preload</a></code> would capture <code>errno</code> before a <code>fread</code> call was attempted, at which point <code>errno</code> is probably <code>0</code>&#8201;&#8212;&#8201;or, worse, leftover from a previous I/O failure.</p>
</div>
<div class="paragraph">
<p>The solution is to use <code><a href="#defer">defer</a></code>, so we don&#8217;t have to remember to include <code>e_errno</code> with each exception; <code>errno</code> will be associated automatically with any exception that escapes <code>read_file</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> read_file(FILE * f) {

  <span class="directive">auto</span> propagate = leaf::defer( [ ] { <span class="keyword">return</span> e_errno{errno} } );

  ....
  size_t nr1=fread(buf1,<span class="integer">1</span>,count1,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error() );

  size_t nr2=fread(buf2,<span class="integer">1</span>,count2,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error() );

  size_t nr3=fread(buf3,<span class="integer">1</span>,count3,f);
  <span class="keyword">if</span>( ferror(f) )
    leaf::throw_exception( file_read_error() );
  ....
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This works similarly to <code>preload</code>, except that capturing of the <code>errno</code> is deferred until the destructor of the <code>propagate</code> object is called, which calls the passed lambda function to obtain the <code>errno</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_augment_in_catch">Augmenting Exceptions in a <code>catch</code></h3>
<div class="paragraph">
<p>What makes <code><a href="#preload">preload</a></code> and <code><a href="#defer">defer</a></code> useful (see <a href="#technique_preload">Preloading Errors</a> and <a href="#technique_defer">Capturing <code>errno</code> with <code>defer</code></a>) is that they automatically include <a href="#e-types">e-type</a> objects with any exception or error reported by a function.</p>
</div>
<div class="paragraph">
<p>But what if we need to include some e-object conditionally? When using excption handling, it would be nice to be able to do this in a <code>catch</code> statement which selectively augments passing exceptions.</p>
</div>
<div class="paragraph">
<p>LEAF supports the following approach, assuming all exceptions derive from <code>std::exception</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span>
{
  ....
  function_that_throws();
  ....
}
<span class="keyword">catch</span>( std::exception <span class="directive">const</span> &amp; e )
{
  <span class="keyword">if</span>( condition )
    leaf::get_error(e).propagate( e_this{....}, e_that{....} );
  <span class="keyword">throw</span>;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The reason we need to use <code><a href="#get_error">get_error</a></code> is that not all exceptions have a <code>leaf::<a href="#error">error</a></code> value associated with them. If the exception we&#8217;re augmenting was thrown using <code><a href="#throw_exception">throw_exception</a></code>, it includes a <code>leaf::error</code> sub-object, and in this case <code>get_error</code> will return that <code>leaf::error</code> value. Also, such exceptions can be intercepted by <code>catch( error e )</code> if needed.</p>
</div>
<div class="paragraph">
<p>But if the caught exception was not thrown by <code>throw_exception</code> (and therefore doesn&#8217;t derive from <code>leaf::error</code>), <code>get_error</code> returns an unspecified <code>leaf::error</code> value, which is temporarily associated with any and all current exceptions, until successfully handled by <code><a href="#handle_exception">handle_exception</a></code>. While this association is imperfect, because it does not pertain to a specific exception object, it is the best that can be done in this case.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_preload_in_c_callbacks">Using <code>peek_next_error</code> in C-callbacks</h3>
<div class="paragraph">
<p>Communicating information pertaining to a failure detected in a C callback is tricky, because C callbacks are limited to a specific static signature, which may not use C&#43;&#43; types.</p>
</div>
<div class="paragraph">
<p>LEAF makes this easy. As an example, we&#8217;ll write a program that uses Lua and reports a failure from a C&#43;&#43; function registered as a C callback, called from a Lua program. The failure will be propagated from C&#43;&#43;, through the Lua interpreter (written in C), back to the C&#43;&#43; function which called it.</p>
</div>
<div class="paragraph">
<p>C/C&#43;&#43; functions designed to be called from a Lua program must use the following signature:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c"><span class="predefined-type">int</span> do_work( lua_State * L );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Arguments are passed on the Lua stack (which is accessible through <code>L</code>). Results too are pushed onto the Lua stack.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s initialize the Lua interpreter and register <code>do_work</code> as a C callback, available for Lua programs to call:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::shared_ptr&lt;lua_State&gt; init_lua_state() <span class="directive">noexcept</span>
{
  std::shared_ptr&lt;lua_State&gt; L(lua_open(),&amp;lua_close); <i class="conum" data-value="1"></i><b>(1)</b>

  lua_register( &amp;*L, <span class="string"><span class="delimiter">&quot;</span><span class="content">do_work</span><span class="delimiter">&quot;</span></span>, &amp;do_work ); <i class="conum" data-value="2"></i><b>(2)</b>

  luaL_dostring( &amp;*L, <span class="string"><span class="delimiter">&quot;</span></span><span class="error">\</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="error">\</span>n      function call_do_work()\
<span class="error">\</span>n          <span class="keyword">return</span> do_work()\
<span class="error">\</span>n      end<span class="string"><span class="delimiter">&quot;</span><span class="content"> );

  return L;
}</span></span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new <code>lua_State</code>. We&#8217;ll use <code>std::shared_ptr</code> for automatic cleanup.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Register the <code>do_work</code> C&#43;&#43; function as a C callback, under the global name <code>do_work</code>. With this, calls from Lua programs to <code>do_work</code> will land in the <code>do_work</code> C&#43;&#43; function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass some Lua code as a <code>C</code> string literal to Lua. This creates a global Lua function called <code>call_do_work</code>, which we will later ask Lua to execute.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Next, let&#8217;s define our <a href="#e-types">e-type</a> used to communicate <code>do_work</code> failures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> e_do_work_error { <span class="predefined-type">int</span> value; };</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define the <code>do_work</code> function.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> do_work( lua_State * L ) <span class="directive">noexcept</span>
{
  <span class="predefined-type">bool</span> success=rand()%<span class="integer">2</span>; <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="keyword">if</span>( success )
  {
    lua_pushnumber(L,<span class="integer">42</span>); <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">return</span> <span class="integer">1</span>;
  }
  <span class="keyword">else</span>
  {
    leaf::error::peek_next_error().propagate( e_do_work_error{-<span class="integer">42</span>} ); <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="keyword">return</span> luaL_error(L,<span class="string"><span class="delimiter">&quot;</span><span class="content">do_work_error</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="4"></i><b>(4)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>"Sometimes" <code>do_work</code> fails.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In case of success, push the result on the Lua stack, return back to Lua.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Associate an <code>e_do_work_error</code> object with the <strong>next</strong> <code>leaf::error</code> object we will definitely return from the <code>call_lua</code> function (below)&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;once control reaches it, after we tell the Lua interpreter to abort the program.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;ll write the function that calls the Lua interpreter to execute the Lua function <code>call_do_work</code>, which in turn calls <code>do_work</code>. We&#8217;ll return <code><a href="#result">result</a>&lt;int&gt;</code>, so that our caller can get the answer in case of success, or an error:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;<span class="predefined-type">int</span>&gt; call_lua( lua_State * L )
{
  lua_getfield( L, LUA_GLOBALSINDEX, <span class="string"><span class="delimiter">&quot;</span><span class="content">call_do_work</span><span class="delimiter">&quot;</span></span> );
  <span class="keyword">if</span>( <span class="predefined-type">int</span> err=lua_pcall(L,<span class="integer">0</span>,<span class="integer">1</span>,<span class="integer">0</span>) ) <i class="conum" data-value="1"></i><b>(1)</b>
  {
    <span class="directive">auto</span> propagate = leaf::preload( e_lua_error_message{lua_tostring(L,<span class="integer">1</span>)} ); <i class="conum" data-value="2"></i><b>(2)</b>
    lua_pop(L,<span class="integer">1</span>);
    <span class="keyword">return</span> leaf::error( e_lua_pcall_error{err} );
  }
  <span class="keyword">else</span>
  {
    <span class="predefined-type">int</span> answer=lua_tonumber(L,-<span class="integer">1</span>); <i class="conum" data-value="3"></i><b>(3)</b>
    lua_pop(L,<span class="integer">1</span>);
    <span class="keyword">return</span> answer;
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ask the Lua interpreter to call the global Lua function <code>call_do_work</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Something went wrong with the call, so we&#8217;ll return a <code>leaf::<a href="#error">error</a></code>. If this is a <code>do_work</code> failure, the <code>e_do_work_error</code> object prepared in <code>do_work</code> will become associated with this <code>leaf::error</code> value. If not, we will still need to communicate that the <code>lua_pcall</code> failed with an error code and an error message.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Success! Just return the int answer.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, here is the <code>main</code> function which handles all failures:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="predefined-type">int</span> main() <span class="directive">noexcept</span>
{
  std::shared_ptr&lt;lua_State&gt; L=init_lua_state();

  leaf::expect&lt;e_do_work_error,e_lua_pcall_error,e_lua_error_message&gt; exp; <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="keyword">for</span>( <span class="predefined-type">int</span> i=<span class="integer">0</span>; i!=<span class="integer">10</span>; ++i )
    <span class="keyword">if</span>( leaf::result&lt;<span class="predefined-type">int</span>&gt; r = call_lua(&amp;*L) )
      std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">do_work succeeded, answer=</span><span class="delimiter">&quot;</span></span> &lt;&lt; *r &lt;&lt; <span class="char">'\n'</span>; <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">else</span>
    {
      <span class="predefined-type">bool</span> matched = handle_error( exp, r,

        leaf::match&lt;e_do_work_error&gt;( [ ]( <span class="predefined-type">int</span> v ) <i class="conum" data-value="3"></i><b>(3)</b>
        {
          std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Got e_do_work_error, value = </span><span class="delimiter">&quot;</span></span> &lt;&lt; v &lt;&lt;  <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
        } ),

        leaf::match&lt;e_lua_pcall_error,e_lua_error_message&gt;( [ ]( <span class="predefined-type">int</span> err, std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; msg ) <i class="conum" data-value="4"></i><b>(4)</b>
        {
          std::cout &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">Got e_lua_pcall_error, Lua error code = </span><span class="delimiter">&quot;</span></span> &lt;&lt; err &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span> &lt;&lt; msg &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
        } )
      );
      assert(matched);
    }
  <span class="keyword">return</span> <span class="integer">0</span>;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Tell LEAF what <a href="#e-types">e-objects</a> are expected.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the call to <code>call_lua</code> succeeded, just print the answer.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle <code>e_do_work</code> failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Handle all other <code>lua_pcall</code> failures.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Follow this link to see the complete program: <a href="https://github.com/zajo/leaf/blob/master/example/lua_callback_result.cpp?ts=3">lua_callback_result.cpp</a>.</p>
</div>
<div class="paragraph">
<p>Remarkably, the Lua interpreter is C&#43;&#43; exception-safe, even though it is written in C. Here is the same program, this time using a C&#43;&#43; exception to report failures from <code>do_work</code>: <a href="https://github.com/zajo/leaf/blob/master/example/lua_callback_eh.cpp?ts=3">lua_callback_eh.cpp</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="technique_transport">Transporting Errors between Threads</h3>
<div class="paragraph">
<p>With LEAF, <a href="#e-types">e-objects</a> use automatic storage duration, stored inside <code><a href="#expect">expect</a></code> instances. When using concurrency, we need a mechanism to detach e-objects from a worker thread and transport them to another thread where errors are handled.</p>
</div>
<div class="paragraph">
<p>LEAF offers two interfaces for this purpose, one using <code>result&lt;T&gt;</code>, and for programs that use exception handling.</p>
</div>
<div class="sect3">
<h4 id="technique_transport-result">Using <code>result&lt;T&gt;</code></h4>
<div class="paragraph">
<p>Without exceptions, transporting <a href="#e-types">e-objects</a> between threads is as easy as calling <code><a href="#capture-result">capture</a></code>, passing the <code><a href="#expect">expect</a></code> object whose contents needs to be transported, and a <code><a href="#result">result</a>&lt;T&gt;</code> which may be in either value state or error state. This gets us a new <code><a href="#result">result</a>&lt;T&gt;</code> object which can be sent across thread boundaries.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume we have a <code>task</code> which produces a result but could also fail:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">leaf::result&lt;task_result&gt; task();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To prepare the returned <code>result</code> to be sent across the thread boundary, when we launch the asynchronous task, we wrap it in a lambda function that captures its result:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::future&lt;leaf::result&lt;task_result&gt;&gt; launch_task()
{
  <span class="keyword">return</span> std::async( std::launch::async, [ ]
    {
      leaf::expect&lt;E1,E2,E3&gt; exp;
      <span class="keyword">return</span> capture(exp,task());
    } );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can process the returned <code>result&lt;task_result&gt;</code> as if it was generated locally:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">....
leaf::expect&lt;E1,E2,E3&gt; exp;

<span class="keyword">if</span>( leaf::result&lt;task_result&gt; r = fut.get() )
{
  <span class="comment">//Success! Use *r to access task_result.</span>
}
<span class="keyword">else</span>
{
  handle_error( exp, r,

    leaf::match&lt;E1,E2&gt;( [ ] ( .... )
    {
      <span class="comment">//Deal with E1, E2</span>
    } ),

    leaf::match&lt;E3&gt;( [ ] ( .... )
    {
      <span class="comment">//Deal with E3</span>
    } )

  );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/zajo/leaf/blob/master/example/capture_result.cpp?ts=3">capture_result.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="technique_transport-exceptions">Using Exception Handling</h4>
<div class="paragraph">
<p>When using exception handling, we need to capture the exception using <code>std::exception_ptr</code>, then capture the current <a href="#e-types">e-objects</a> in an <code><a href="#error_capture">error_capture</a></code> and wrap both into another exception. In the main thread we unwrap and throw the original exception.</p>
</div>
<div class="paragraph">
<p>This, of course, is done automatically by LEAF. Let&#8217;s assume we have a <code>task</code> which produces a <code>task_result</code> and throws on errors:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">task_result task();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When we launch the asynchronous task, we wrap it in a simple lambda function which calls <code><a href="#capture_exception">capture_exception</a></code>, specifying which <a href="#e-types">e-objects</a> we need transported:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">std::future&lt;task_result&gt; launch_task()
{
  <span class="keyword">return</span> std::async( std::launch::async,
    leaf::capture_exception&lt;E1,E2,E3&gt;( [ ]
      {
        <span class="keyword">return</span> task();
      } ) );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Later, instead of using <code>std::future::get</code>, we use <code>leaf::<a href="#get">get</a></code>, then catch exceptions as if the function was called locally:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">....
leaf::expect&lt;E1,E2,E3&gt; exp;

<span class="keyword">try</span>
{
  task_result r = leaf::get(fut);
  <span class="comment">//Success!</span>
}
<span class="keyword">catch</span>( my_exception &amp; e )
{
  handle_exception( exp, e,

    leaf::match&lt;E1,E2&gt;( [ ] ( .... )
    {
      <span class="comment">//Deal with E1, E2</span>
    } ),

    leaf::match&lt;E3&gt;( [ ] ( .... )
    {
      <span class="comment">//Deal with E3</span>
    } )

  );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/zajo/leaf/blob/master/example/capture_eh.cpp?ts=3">capture_eh.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_design_rationale">Design Rationale</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first observation driving the LEAF design is that unless a specific type of info (e.g. a file name) is used at the time an error is being handled, there is no need for it to be reported. On the other hand, if the error handling context can use or requires some info, it would not be burdened by having to explicitly declare that need. The end result of this reasoning is <code><a href="#expect">expect</a></code>.</p>
</div>
<div class="paragraph">
<p>The second observation is that ideally, like any other communication mechanism, it makes sense to formally define an interface for the error info that can be used by the error handling code. In terms of C&#43;&#43; exception handling, it would be nice to be able to say something like:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">try</span> {

  process_file();

} <span class="keyword">catch</span>( file_read_error&lt;e_file_name,e_errno&gt; &amp; e ) {

  std::cerr &lt;&lt;
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not read </span><span class="delimiter">&quot;</span></span> &lt;&lt; e.get&lt;e_file_name&gt;() &lt;&lt;
    <span class="string"><span class="delimiter">&quot;</span><span class="content">, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; e.get&lt;e_errno&gt;() &lt;&lt; std::endl;

} <span class="keyword">catch</span>( file_read_error&lt;e_errno&gt; &amp; e ) {

  std::cerr &lt;&lt;
    <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error, errno=</span><span class="delimiter">&quot;</span></span> &lt;&lt; e.get&lt;e_errno&gt;() &lt;&lt; std::endl;

} <span class="keyword">catch</span>( file_read_error&lt;&gt; &amp; e ) {

  std::cerr &lt;&lt; <span class="string"><span class="delimiter">&quot;</span><span class="content">File read error!</span><span class="delimiter">&quot;</span></span> &lt;&lt; std::endl;

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That is to say, it is desirable to be able to dispatch error handling based not only on the kind of failure being handled, but also based on the kind of error info available. Unfortunately this syntax is not possible and, even if it were, not all programs use exceptions to handle errors. The result of this train of thought is <code><a href="#handle_error-expect">handle_error</a></code>/<code><a href="#handle_exception">handle_exception</a></code>.</p>
</div>
<div class="paragraph">
<p>Last but not least, there is certain redundancy and repetition in error-neutral contexts that simply forward errors to their caller. What is the point in receiving some error info from a lower level function (e.g. a file name), when at this point we can&#8217;t do anything with it, except forward it to our caller, until we reach a scope that can actually make use of the data? Even with move semantics, why bother move such data one level at a time, from one stack location to another immediately above, only to move it again when we <code>return</code> again?</p>
</div>
<div class="paragraph">
<p>It is more correct for such information to be passed from a context where it is available, <em>directly to the exact stack location where it would be accessed by the error handling code</em>. This is another reason why the storage for <a href="#e-types">e-objects</a> is provided by <code><a href="#expect">expect</a></code> instances, which all use automatic storage duration.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distribution">Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright (c) 2018 Emil Dotchevski.</p>
</div>
<div class="paragraph">
<p>LEAF is distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>The source code is available in <a href="https://github.com/zajo/leaf">this GitHub repository</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
LEAF is not part of Boost. Please post questions and feedback on the Boost Developers Mailing List.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="building">Building</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF is a header-only library and it requires no building. The unit tests use Boost Build, but the library itself has no dependency on Boost or any other library.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF requires a C&#43;&#43;11 compiler.</p>
</div>
<div class="paragraph">
<p>See unit test matrix at <a href="https://travis-ci.org/zajo/leaf">Travis-CI</a>. It has also been tested with Microsoft Visual Studio 2015 and 2017.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Except when transporting error info between threads, see <a href="#capture-expect"><code>capture</code></a>.
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>